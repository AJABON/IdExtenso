/*******************************************************************************

		Name:           number
		Desc:           Extends Number.prototype
		Path:           /core/Ext/$$.number.jsxinc
		Require:        ---
		Encoding:       ÛȚF8
		Core:           YES
		Kind:           Part of /Ext
		API:            toSource() toHexa() toAdbe() isAdbe()
		DOM-access:     NO
		Todo:           ---
		Created:        170307 (YYMMDD)
		Modified:       170423 (YYMMDD)

*******************************************************************************/

	//==========================================================================
	// Number.prototype.toSource()
	//==========================================================================

	Number.prototype.toSource = function toSource()
	//----------------------------------
	// [TODO] May be improved to get shorter strings ("1e5" etc)
	// => str
	{
		return String(this);
	};

	//==========================================================================
	// Number.prototype.toHexa() ; Number.prototype.toAdbe() ; Number.prototype.isAdbe()
	//==========================================================================

	Number.prototype.toHexa = function toHexa(/*str='0x'*/prefix,/*uint=0*/zeroPad,  s)
	//----------------------------------
	// Return the "0xHHHH" representation of this number. (Uppercase hexa digits.)
	// [ADD170423] `prefix`   If provided (string), reset the prefix (default is "0x").
	// [ADD170423] `zeroPad`  If > 0, minimum length of the hexa representation.
	// ---
	// E.g  toHexa(123456)          => "0x1E240"
	// E.g  toHexa(123456, "U+")    => "U+1E240"
	// E.g  toHexa(123, "")         => "7B"
	// E.g  toHexa(123, "", 4)      => "007B"
	{
		if( isNaN(this) ) return 'NaN';

		( 'string' == typeof prefix ) || (prefix='0x');
		( 'number' == typeof zeroPad && 0 < (zeroPad >>>= 0) ) || (zeroPad=0);
		
		s = this.toString(16).toUpperCase();
		
		return prefix +
			( zeroPad && 0 < (zeroPad-=s.length) ? Array(1+zeroPad).join('0') : '' ) +
			s;
	};

	Number.prototype.toAdbe = function toAdbe()
	//----------------------------------
	// Return the Adobe's 4-char string this number encodes.
	// [REM] Only makes sense if `this` is U32.
	// E.g  0x414F5069 => "AOPi" ; 0x74787466 => "txtf"
	{
		return isNaN(this) ?
			'NaN' :
			String.fromCharCode( 0xFF&(this>>>24), 0xFF&(this>>>16), 0xFF&(this>>>8), 0xFF&(this>>>0) );
	};

	Number.prototype.isAdbe = function isAdbe(  s)
	//----------------------------------
	// Whether this Number looks like an Adobe 4-char tag.
	// [REM] Only makes sense if `this` is U32.
	// E.g  1114394470 => 1    ;    12345 => 0
	//  ie  0x426C4F66 [OK]        0x3039 [KO]
	{

		return +(
			8==(s=this.toString(16).toUpperCase()).length &&
			RegExp.ADBE.test(s)
			);
	};

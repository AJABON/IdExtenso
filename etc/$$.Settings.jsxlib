/*******************************************************************************

		Name:           Settings
		Desc:           Encapsulates a set of custom settings to be handled throughout a script.
		Path:           /etc/$$.Settings.jsxlib
		Require:        Dom/label ; $$.kill() $$.clone()
		Encoding:       ÛȚF8
		Core:           NO
		Kind:           Module.
		API:            =access() declare() hasScope() canDeclare()
		                activate() reset() backup()
		                addLive() objKeyCount() appKeyCount()
		DOM-access:     extractLabel() insertLabel()
		Todo:           documentation.
		Created:        150630 (YYMMDD)
		Modified:       180309 (YYMMDD)

*******************************************************************************/

;$$.hasOwnProperty('Settings') || eval(__(MODULE, $$, 'Settings', 180309, 'access'))

	//==========================================================================
	// NOTICE
	//==========================================================================

	/*

	KEY SCOPES (SUMMARY)
	
	============================================================================
	BRANCH   TYPE     DECL  ACTIVATE   RESET       BCKP   DESCRIPTION
	============================================================================
	CONST    CNST= 1  VAL   NOOP       NOOP        NOOP   Read-only.
	----------------------------------------------------------------------------
	LIVE     LIVE= 2  VAL   NOOP       NOOP        NOOP   Volatile (no default.)
	----------------------------------------------------------------------------
	RESET    RSET= 4  DEF   DEF        DEF         NOOP   Restorable but non-persistent.
	----------------------------------------------------------------------------
	[ENGINE] ENGI= 8  DEF   VAL?:DEF   DEF         NOOP   Engine-persistent (if present.)
	                                                      This is the default scope.
	----------------------------------------------------------------------------
	SESSION  SESS=16  DEF   VAL        DEF         NOOP   Session-persistent
	                                                      (even in main engine.)
	----------------------------------------------------------------------------
	OBJ      DOBJ=32  DEF   OBJ?:      null?DEF:   null?  DOM-Object-persistent.
	                        VAL?:DEF   OBJ?:DEF    NOOP:
	                                               OBJ?:
	                                               NOOP
	----------------------------------------------------------------------------
	APP      INDD=64  DEF   APP?:      null?DEF:   null?  App-persistent.
	                        VAL?:DEF   APP?:DEF    NOOP:
	                                               APP
	----------------------------------------------------------------------------
	HYB      HYBR=96  DEF   OBJ?:      null?DEF:   null?  Hybrid.
	                        APP?:      OBJ?:       NOOP:
	                        VAL?:DEF   APP?:DEF    OBJ?:
	                                               APP
	----------------------------------------------------------------------------

	*/

	[PRIVATE]

	({
		// Scopes
		// ---
		CNST :  1,   // Constant key, can't be changed.
		LIVE :  2,   // Live key, free to change, no default, volatile.
		RSET :  4,   // Similar to live, but can be restored to its default.
		ENGI :  8,   // Engine-persistent (if a non-main engine is in use.)
		SESS : 16,   // Session-persistent (whatever the engine in use.)
		DOBJ : 32,   // Object-persistent (if a DOM object is provided.)
		INDD : 64,   // Application-persistent.
		HYBR : 96,   // Hybrid scope (DOBJ or INDD)
		
		BRCH : function(/*key*/s)
		//----------------------------------
		// (Branch-Map.) Map a user-friendly branch name to a scope.
		// => 0 [KO]  |  1|2|4|8|... [OK]
		{
			return (s=callee.Q[s]) ? this[s] : 0;
		}.setup({ Q:
			{
			'CONST':   'CNST',  // The branch 'CONST' is not required, use `_MYCONSTANT` instead.
			'LIVE':    'LIVE',
			'RESET':   'RSET',
			'ENGINE':  'ENGI',  // The branch 'ENGINE' is not required, that's the default scope.
			'SESSION': 'SESS',
			'OBJ':     'DOBJ',
			'APP':     'INDD',
			'HYB':     'HYBR',
			},
			// [180308] Added for extra parsing.
			// ---
			RE: /^CNST|LIVE|RSET|ENGI|SESS|DOBJ|INDD|HYBR$/,
		}),

		FDEL : function(/*obj&*/o,/*key*/k)
		//----------------------------------
		// (Deleter.) Kill and delete `o[k]`.
		// this :: ~
		// => o
		{
			$.global[callee.µ.__root__].kill(o[k]);
			delete o[k];
			return o;
		},

		FSET : function(/*obj&*/o,/*key*/k,/*any*/v)
		//----------------------------------
		// (Setter.) Kill `o[k]` first, then clone `v` in it.
		// this :: ~
		// => o[k]
		{
			this.FDEL(o,k);
			return (o[k]=$.global[callee.µ.__root__].clone(v));
		},

	})

	[PRIVATE]
	
	({
		// Settings-Unique-ID.
		// ---
		SUID : '',

		KEYS : {/*key => fct*/},
		
		// Resettable mask. (Any scope that &-matches RSBL supports the reset feature.)
		// ---
		RSBL : (µ['~'].RSET)|(µ['~'].ENGI)|(µ['~'].SESS)|(µ['~'].DOBJ)|(µ['~'].INDD)|(µ['~'].HYBR),

		KSCO : function(/*key*/k)
		//----------------------------------
		// (Key-Scope.) this :: ~
		// => 0 [KO]  |  1|2|4|8|... [OK]
		{
			return callee.Q[k] || 0;
		}.setup({ Q:{} }),

		KDEF : function(/*key*/k)
		//----------------------------------
		// (Key-Default.) this :: ~
		// => undefined [KO]  |  <any> [OK]
		{
			return callee.Q.hasOwnProperty(k) ? callee.Q[k] : (void 0);
		}.setup({ Q:{} }),

		WTCH : function(/*key*/k,/*?any*/ov,/*?any|NULL*/nv,  I)
		//----------------------------------
		// (Key-Watcher.) Use null to default.
		// this :: ~.KEYS
		{
			return (I=callee.µ['~']),
			(
				( (I.CNST)&(I.KSCO(k)) ) ? ov :
				(
					null===nv ?
					I.KDEF(k) :
					[this.unwatch(k),I.FSET(this,k,nv),this.watch(k,callee)][1]
				)
			);
		},

	})

	[PRIVATE]
	
	({
		GOBJ : function(/*dom*/osp,/*any*/defRet)
		//----------------------------------
		// (Get-From-Obj.) Get (extract) keys from osp's SUID label.
		// => new set [OK] | undefined [KO]
		{
			return $.global[callee.µ.__root__].Dom.fromLabel(osp, this.SUID, defRet);
		},

		SOBJ : function(/*dom*/osp,/*any{}*/o)
		//----------------------------------
		// (Set-to-Obj.) Set (insert) o keys into osp's SUID label.
		// => str (json)
		{
			return $.global[callee.µ.__root__].Dom.toLabel(osp, this.SUID, o);
		},

		GAPP : function(/*any*/defRet)
		//----------------------------------
		// (Get-From-App.) Get keys from app's SUID label.
		// => new set [OK] | undefined [KO]
		{
			return this.GOBJ(app,defRet);
		},

		SAPP : function(/*any{}*/o)
		//----------------------------------
		// (Set-to-App.) Set o keys into app SUID label.
		// => str (json)
		{
			return this.SOBJ(app,o);
		},

		GENV : function(/*str*/k,  s)
		//----------------------------------
		// (Get-From-Env.) Get (extract) this key from the env-var `SUID_<k>`.
		// => any value [OK] | null [KO]
		{
			return (s=$.getenv(this.SUID+'_'+k)) ? $.global[callee.µ.__root__].JSON.eval(s) : null;
		},

		SENV : function(/*str*/k,/*any*/x,  s)
		//----------------------------------
		// (Set-To-Env.) Set this key in the env-var `SUID_<k>`.
		// => str (json)
		{
			$.setenv(this.SUID+'_'+k, s=$.global[callee.µ.__root__].JSON.lave(x));
			return s;
		},

	})

	[PRIVATE]
	
	({
		ONUM : 0,
		ANUM : 0,
		MASK : 0, // Mask of all added scopes. [ADD180308]

		DELK : function(  o,k)
		//----------------------------------
		// (Delete-Keys.) Unwatch and remove all existing keys.
		{
			o = this.KEYS;
			for( k in o )
			{
				if( !o.hasOwnProperty(k) ) continue;
				o.unwatch(k);
				this.FDEL(o,k);
				this.FDEL(this.KDEF.Q,k);
				delete this.KSCO.Q[k];
			}
		},

		ADDK : function(/*key*/k,/*uint*/scope,/*any*/data)
		//----------------------------------
		// (Add-Key.) Throws an error if it already exists.
		{
			if( this.KEYS.hasOwnProperty(k) )
			{
				$.global[callee.µ.__root__].error(__("The key '%1' is already declared.",k), callee);
			}

			this.KSCO.Q[k] = scope;
			
			if( scope == this.LIVE || scope == this.CNST )
			{
				this.FSET(this.KEYS, k, data);
			}
			else
			{
				this.FSET(this.KDEF.Q, k, data);
				this.KEYS[k] = void 0; // undefined -> must be activated!
			}
			
			this.MASK |= scope; // [ADD180308]
		},

		DECL : function(/*str*/suid,/*{...,LIVE:{},RESET:{},OBJ:{},APP:{},HYB:{}}*/o,  k,z,oo)
		//----------------------------------
		// (Declare-All-Settings.)
		// [REM] Branch names are case-sensitive.
		{
			// Kills existing keys (if any.)
			// ---
			this.SUID && this.DELK();

			// Set the 'Settings Unique ID.'
			// ---
			this.SUID = suid;
			
			// Reset the scope mask to zero.
			// ---
			this.MASK = 0;
			
			// Parse input and create keys from scratch.
			// ---
			for( k in o )
			{
				if( !o.hasOwnProperty(k) ) continue;
				
				if( !(z=this.BRCH(k)) )
				{
					// Implicit scope is determined as follows:
					// I.CNST if key has the form '_xxx' ('_' is then removed),
					// I.ENGI otherwise.
					// ---
					z = this['_' == k[0] ? 'CNST' : 'ENGI'];
					this.ADDK(k.substr(1&z),z,o[k]);
					continue;
				}
	
				// Here o[k] is a z-scoped branch, and must be an object.
				// ---
				if( Object(oo=o[k])!==oo )
				{
					$.global[callee.µ.__root__].error(
						__("The declaration of the branch '%1' is not valid. (Not an object.)", k),
						callee );
				}
				
				for( k in oo )
				{
					oo.hasOwnProperty(k) && this.ADDK(k, z, oo[k]);
				}
			}
		},

		ACRS : function(/*?dom|null*/host,/*bool*/DO_RESET,  o,k,z,v,indd,dobj,zo,za)
		//----------------------------------
		// (Activate-Or-Reset.) Activate or Reset declared keys.
		{
			o = this.KEYS;
			indd = dobj = false;
			za = zo = 0;
	
			for( k in o )
			{
				if( !o.hasOwnProperty(k) ) continue;

				z = this.KSCO(k);
				v = null;

				// If the key is resettable, determine its activation value.
				// [REM] LIVE and CNST keys are excluded from this block.
				// ---
				while( z&this.RSBL )
				{
					// [ADD180221] Manage session key thru $.getenv(<SUID>_<KEY>)
					// SESS
					// ---
					if( (z&this.SESS) && null!==(v=this.GENV(k)) ) break;

					// DOBJ | INDD | HYBR
					// If DO_RESET && host===null, take the default and break.
					// ---
					if( (z&this.HYBR) && DO_RESET && null===host ){ v=this.KDEF(k); break; }
					
					// DOBJ | HYBR
					// ---
					if( (z&this.DOBJ) )
					{
						// If not already done, unserialize data from the host object.
						// ---
						host && (false===dobj) && (dobj=this.GOBJ(host, void 0));
						
						// Look for the key.
						// [REM] If not found in a hybrid key, do not break!
						// ---
						if( dobj && dobj.hasOwnProperty(k) ){ ++zo; v=dobj[k]; break; }
					}

					// INDD | HYBR
					// ---
					if( (z&this.INDD) )
					{
						// If not already done, unserialize data from the app.
						// ---
						(false===indd) && (indd=this.GAPP(void 0));
						
						// Look for the key.
						// ---
						if( indd && indd.hasOwnProperty(k) ){ ++za; v=indd[k]; break; }
					}

					// RESET
					// Take the default value in any of the following cases:
					// (a) forced reset ; (b) RSET key ; (c) key undefined.
					// ---
					if( DO_RESET || (z&this.RSET) || ('undefined'==typeof this.KEYS[k]) )
					{
						v = this.KDEF(k);
					}
					break;
				}

				// Set or change the existing key into its activation value.
				// ---
				o.unwatch(k);
				null===v || (this.FSET(o,k,v))
				o.watch(k,this.WTCH);
			}
			
			// Indicate whether OBJ and/or APP labels have been found during activation,
			// and how many properties have been restored from each.
			// ---
			this.ONUM = zo;
			dobj && $.global[callee.µ.__root__].kill(dobj);

			this.ANUM = za;
			indd && $.global[callee.µ.__root__].kill(indd);
		},

		BCKP : function(/*?dom|null*/host,  indd,dobj,SKIP_HYB,zo,za,o,k,z)
		//----------------------------------
		// (Backup.)
		{
			indd = this.GAPP({});                // Get the existing app keys, or {}, in a new obj
			dobj = host && this.GOBJ(host,{}),   // Get the existing obj keys, or {}, in a new obj
	
			SKIP_HYB = +(null===host);

			zo = za = 0;
	
			o = this.KEYS;
			for( k in o )
			{
				if( !o.hasOwnProperty(k) ) continue;
				
				z = this.KSCO(k);
	
				// SESS
				// ---
				if( z&this.SESS )
				{
					this.SENV(k,o[k]);
					continue;
				}
	
				// OBJ | HYB
				// ---
				if( z&this.DOBJ )
				{
					if( SKIP_HYB ) continue;
					if( host ){ ++zo; dobj[k]=o[k]; continue; }
				}
	
				// APP | HYB
				// ---
				if( z&this.INDD )
				{
					++za;
					indd[k]=o[k];
				}
			}
	
			zo && this.SOBJ(host,dobj);
			$.global[callee.µ.__root__].kill(dobj);
			
			za && this.SAPP(indd);
			$.global[callee.µ.__root__].kill(indd);
		},
	})

	//==========================================================================
	// API
	//==========================================================================

	[PUBLIC]
	
	({
		declare : function declare_S_Õ_(/*str*/suid,/*{...,LIVE:{},RESET:{},SESSION:{},OBJ:{},APP:{},HYB:{}}*/oInput,  I)
		//----------------------------------
		// Create a set of keys from scratch and register their default values. This function must be
		// called *once* per engine, and before `activate()`. It does not restore nor enable any key.
		// Recommended usage:  $$.Settings.canDeclare() && $$.Settings.declare(...);
		// ---
		// suid   :: Settings unique ID (string.)
		// oInput :: Set of keys with their default values, e.g { myString:"foobar", myNumber:123, ... }
		//           By default, keys are ENGINE-scoped, meaning they keep their latest value as long as
		//           the engine is active. Keys declared with underscore prefix (`_`) are made constant,
		//           so they cannot be changed even using `ss.MYKEY = newValue`. (Note: the `_` prefix
		//           is automatically removed from the key name.) To declare additional scopes, use any
		//           of the following branch: LIVE, RESET, SESSION, OBJ, APP, HYB. For example,
		//           { mySimpleKey:"foobar", _MYCONST:3.14, SESSION: { mySessionKey:321 } }
		// ---
		// [REM] You can explicitly use the branches CONST and ENGINE.
		// [REM] An error is thrown if a key name is re-used or anything else
		// goes wrong during the declaration.
		// ---
		// Full oInput example:
		//    {
		//    _PROGNAME: "MyProgram",            // Contant key named PROGNAME; its value cannot be changed.
		//    indexMode: "auto",                 // Engine-persistent. The latest value remains as long as
		//                                       // this engine is alive--assuming you don't call reset().
		//                                       // REM: Will work as RESET if no persistent engine is active.
		//    LIVE:      { tempValue: "test" },  // Non-persistent and no reset. Can be changed at wish; useful
		//                                       // to pass dynamic data among the settings while perfoming a task.
		//    RESET:     { jobDone: false },     // Non-persistent with auto-reset. This key automatically recovers
		//                                       // its init value *each time you activate* the settings (including
		//                                       // in the context of a persistent engine.)
		//    SESSION:   { runCount: 0 },        // Session-persistent (whatever the engine in use.) Useful to keep
		//                                       // data across multiple runs in basic scripts avoiding #targetengine.
		//                                       // REM: Will work as ENGINE if a persistent engine is active.
		//    OBJ:       { modified: 180221 },   // Stored in a DOM-Object (Document, PageItem, etc.). This key can
		//                                       // be stored in (and restored from) a DOM object, if supplied.
		//                                       // (See activate, backup and reset for more detail.)
		//    APP:       { version: 2.321 },     // Application-persistent. This key is stored/restored at the
		//                                       // application level, which makes it persistent as long as the
		//                                       // user do not trash InDesign preferences.
		//                                       // (See activate, backup and reset for more detail.)
		//    HYB:       { prefSize: [15,10] },  // Object or Application-persistent. This (hybrid) key is stored
		//                                       // and restored either at object or application level, depending
		//                                       // on which argument is supplied to the API. If a DOM object is
		//                                       // provided, it works as OBJ; otherwise it works as APP. Useful
		//                                       // to manage preferences that can be superseded by some object.
		//                                       // (See activate, backup and reset for more detail.)
		//    }
		// ---
		// => undefined
		{
			if( (I=callee.µ['~']).SUID )
			{
				$.global[callee.µ.__root__].error( __("Settings already declared. Use %1.canDeclare() to check.",callee.µ), callee )
			}

			if( ('string' != typeof suid) || suid.length < 1 )
			{
				$.global[callee.µ.__root__].error( __("Empty UID is not allowed."), callee )
			}

			if( oInput !== Object(oInput) )
			{
				$.global[callee.µ.__root__].error( __("Invalid object in settings declaration."), callee )
			}

			$.global[callee.µ.__root__].trace(__("%1 > Declaring settings for uid: %2.",callee.µ,suid.toSource()));

			I.DECL(String(suid), oInput);
		},
		
		canDeclare : function canDeclare_B(  I)
		//----------------------------------
		// Whether declare() can be invoked.
		// => 0 [NO]  |  1 [YES]
		{
			return (I=callee.µ['~']).SUID ? 0 : 1;
		},
		
		hasScope : function hasScope_IS_I(/*uint|str*/scope,  I,t)
		//----------------------------------
		// [ADD180309] Whether the declared settings contain a param
		// having the supplied scope(s).
		// CNST: 1 ; LIVE: 2 ; RSET: 4 ; ENGI: 8 ; SESS:16
		// DOBJ:32 ; INDD:64 ; HYBR:96
		// `scope` may be any combination of single scope values.
		// => >0 [OK]  |  0 [KO]
		{
			if( !(I=callee.µ['~']).SUID )
			{
				$.global[callee.µ.__root__].error( __("Settings must be declared before calling hasScope."), callee );
			}

			if( 'number' != typeof (t=scope) )
			{
				scope = String(scope).toUpperCase();
				t = I.BRCH(scope) || (I.hasOwnProperty(scope) && I.BRCH.RE.test(scope) && I[scope]);
			}
			
			if( !t )
			{
				$.global[callee.µ.__root__].error( __("The scope %1 is not recognized.",scope), callee );
			}

			return t&I.MASK;
		},

		activate : function activate_d_Õ(/*?dom*/host,  I,s)
		//----------------------------------
		// Restore each key to its most relevant value based on its scope.
		// If host is a DOM object, use it as a source for any OBJ or HYB key.
		// If host is not provided or 'falsy,' OBJ keys will behave at default
		// scope and HYB keys will behave at APP scope.
		// => keys-accessor
		{
			if( !(s=(I=callee.µ['~']).SUID) )
			{
				$.global[callee.µ.__root__].error( __("Settings must be declared before activation."), callee );
			}

			$.global[callee.µ.__root__].trace(__("%1 > Activating settings for uid: %2. Host: %3.",callee.µ,s.toSource(),String(host)));

			I.ACRS(host, false);
			return I.KEYS;
		},

		reset : function reset_d$null$_Õ(/*?dom|null*/host,  I)
		//----------------------------------
		// Reset each key to its default or stored value, based on its scope.
		// ---
		// If host is a DOM object or is not provided (undefined), every OBJ,
		// APP and HYB key is activated the usual way, while all other
		// keys are reset to their default value.
		// ---
		// If host===NULL, then all keys are reset to their default, including
		// OBJ, APP and HYB keys.
		// => keys-accessor
		{
			if( !(I=callee.µ['~']).SUID )
			{
				$.global[callee.µ.__root__].error( __("Settings must be declared before calling reset."), callee )
			}

			I.ACRS(host, true);
			return I.KEYS;
		},

		backup : function backup_d$null$_(/*?dom|null*/host,  I)
		//----------------------------------
		// Backup the current values of label-stored keys.
		// If host is a DOM object, use it as a target for any I_OBJ or I_HYB key.
		// If host is undefined, backup I_HYB and I_APP keys in app.
		// If host is NULL, only backup strict I_APP keys (ignoring I_HYB.)
		// => undefined
		{
			if( !(I=callee.µ['~']).SUID )
			{
				$.global[callee.µ.__root__].error( __("Settings must be declared before calling backup."), callee )
			}

			I.BCKP(host);
		},

		addLive : function addLive_Õ_Õ(/*any{}*/oLiveKeys,  I,k)
		//----------------------------------
		// Add LIVE keys to the existing keys.
		// [REM] CANNOT BE USED WHILE NO ACTIVATION IS DONE
		// => keys-accessor
		{
			if( !(I=callee.µ['~']).SUID )
			{
				$.global[callee.µ.__root__].error( __("Settings must be declared before calling addLive."), callee )
			}

			// New LIVE keys
			// ---
			for( k in oLiveKeys )
			{
				if( !oLiveKeys.hasOwnProperty(k) ) continue;
				I.ADDK(k,I.LIVE,oLiveKeys[k]);
				I.KEYS.watch(k,I.WTCH);
			}
	
			return I.KEYS;
		},


		objKeyCount : function objKeyCount_I()
		//----------------------------------
		// => Number of OBJ label key retrieved during activation.
		{
			return callee.µ['~'].ONUM;
		},
	
		appKeyCount : function appKeyCount_I()
		//----------------------------------
		// => Number of APP label key retrieved during activation.
		{
			return callee.µ['~'].ANUM;
		},

		access : function access_k_ÕX(/*str*/k,  I)
		//----------------------------------
		// [ADD180309] `k` argument added: direct key access.
		// => keys-accessor
		{
			if( !(I=callee.µ['~']).SUID )
			{
				$.global[callee.µ.__root__].error( __("Settings must be declared before calling access."), callee )
			}

			if( !I.KEYS.__count__ )
			{
				$.global[callee.µ.__root__].warn( __("%1 > No key available yet in the accessor.",callee.µ) );
			}
			
			return 'undefined'==typeof k ? I.KEYS : I.KEYS[k];
		},
	})
